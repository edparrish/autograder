# Grading

This page describes how to write a simple grading script.

## Preparing for Grading

1. Choose an assignment folder on a computer to store student work.

2. Download the student submissions into the assignment folder using the manager.html page, or from Canvas directly.

3. Run the foldermaker.php script. This script makes folders for each student and places their files into those folders. For example:

        foldermaker.php path/to/test/directory path/to/student/files

4. Run the preparer.php script. This script prepares each student submission for grading. For example:

        preparer.php path/to/test/directory path/to/student/files

5. You may optionally create a batch file or shell script to automate the preparation process.

    On Windows, make a batch file with a name like `prep01.bat` and put the following in the file:

        @echo off
        php -f \Courses\tools\autograde5\foldermaker.php /Courses/cs11/homework/A01
        php -f \Courses\tools\autograde5\preparer.php /Courses/cs11/homework/A01
        pause
        echo on

    On Linux or Mac computers, make a shell script with a name like "TBD" (without the quotes) and put the following in the file:

        TBD

## Creating a Grading Script

1. Choose a folder to store grading scripts like `scripts`.

2. Start a file with a structure like the following:

        <?php
        include_once("/Courses/tools/autograde5/grader.php");
        // Absolute path to student submissions
        define("TEST_DIR", "/Courses/tools/autograde5/testcpp");
        // Other string constants defined here

        $students = null; // for all students
        //$students = array("asn01"); // list student folders to test

        class GradeRunner extends Grader {
            // Test commands to run for each student submission.
            function test() {
                $firstName = $this->getFirstName();
                $lastName = $this->getLastName();
                echo "\nRunning test() for student $firstName $lastName\n";
            }
        }
        $grader = new GradeRunner(TEST_DIR, $students);
        $grader->runTest();
        ?>

2. Include the path the to grader.php file into the script like:
        include_once("C:/Courses/tools/autograde5/grader.php");

3. Define a string constant for a test directory like:
        define("TEST_DIR", "C:/Courses/tools/autograde5/testcpp");

4. Create a grading class extending grader like:

        class GradeRunner extends Grader {

        }

5. Inside the grading class define a function named "test" (without the quotes) where the test commands are placed for testing each student submission.

For a full example grading file see the example files:

- script-template.php
- script-hello.php

## Running Test Commands

This section describes how to create tests for a student submission.

The test of a students work contains one or more test cases. The test cases are subclasses of class `TestCase`. We will look at several examples of `TestCase` subclasses. File `testcase.php` has all the documentation.

The Grader class has three functions for executing a `TestCase`. When executing a `TestCase`, the `Grader` records the results of the testing such as scores and messages in a `TestResult` object. The documentation for each function is shown below.

        /**
            Run a TestCase and record test items in $this->results.

            @param $testCase The TestCase to run.
            @param $condition Whether or not to run the TestCase.
            @return true if the TestCase ran and passed, otherwise false.
         */
        function run($testCase, $condition = true)

        /**
            Run a TestCase and add points plus a message if the test passes.

            @param $testCase The TestCase to run.
            @param $value The points to add when the TestCase passes.
            @param $msg The message to add when the TestCase passes.
            @param $condition Whether or not to run the TestCase.
            @return true if the TestCase ran and passed, otherwise false.
         */
        function pass($testCase, $value, $msg = "", $condition = true)

        /**
            Run a TestCase and add points plus a message if the test fails.

            @param $testCase The TestCase to run.
            @param $value The points to add when the TestCase fails.
            @param $msg The message to add when the TestCase fails.
            @param $condition Whether or not to run the TestCase.
            @return true if the TestCase ran and passed, otherwise false.
         */
        function fail($testCase, $value, $msg = "", $condition = true) {

        /**
            Run a TestCase and add points and a message if the test passes.

            @param $testCase The TestCase to run.
            @param $passPts The points to apply when the TestCase passes.
            @param $passMsg The message to post when the TestCase passes.
            @param $failPts The points to apply when the TestCase fails.
            @param $failMsg The message to post when the TestCase fails.
            @param $condition Whether or not to run the TestCase.
            @return true if the TestCase passed, otherwise false.
         */
        function passFail($testCase, $passPts, $passMsg, $failPts, $failMsg, $condition = true)

We use these functions when developing the scripts to test a student's work. In general there are six steps to creating a test script:

1. [Find the file to grade.](#1-find-the-file-to-grade)
2. [Compile source code (for compiled languages).](#2-compile-source-code)
3. [Run compiled program with defined input and save the output.](#3-run-compiled-program-with-defined-input-and-save-the-output)
4. [Check the output and comment on problems.](#4-check-the-output-and-comment-on-problems)
5. [Check the source code file for required elements.](#5-check-the-source-code-file-for-any-required-elements)
6. [Evaluate and score the combined test results.](#6-evaluate-and-score-the-combined-test-cases)

Some of the steps are optional. We will cover these steps in the following sections.

## 1. Find the file to grade

One can simply require students to use a specific name and give the students a score of zero (0) for files that are not named exactly correct. For example:

    $testFile = "hello.cpp";

However, students may make mistakes in spelling, capitalization and other errors so we may want to make some allowances. The `Grader` superclass contains a function to allow some variation in naming:

    /**
        Finds a single file in the current directory that most closely
        matches the $fileName, $glob and $contentRegEx. If multiple files
        match, then the file within the closest distance (minimum number of
        character changes in the name) is selected.

        @param $fileName The name of the file.
        @param $glob The glob file pattern to search within.
        @param $contentREList A list of regex patterns of file contents.
        @return the closest matching file name.
     */
    function findClosestFile($fileName, $glob = "*", $contentREList = "")

As an example of calling the function:

    // Find the test file
    $fileName = "hello.cpp";
    $glob = "[hH]el*.cpp";
    $contentRE = "/\bHell?o\b/";
    $testFile = $this->findClosestFile($fileName, $glob, $contentRE);

If we want to record the test file selected in the grade log, we may use the Grader method `writeGradeLog()`. All files ending in ".log" are collected into one grade.log file at the end of testing.

    $this->writeGradeLog("Testing file $testFile\n");

To allow for even more vague file naming, one may use the `FileFinder` class to find files. The `FileFinder` allows us to start with a glob and apply various filters to eliminate unlikely files. See the `FileFinder` class for documentation.

## 2. Compile source code

Compiling is a two step process.

1. First create a TestCompileCPP object for the file to compile like:

        $tc = new TestCompileCPP($testFile);

    The `TestCompileCPP` is a `TestCase` subclass that knows how to compile C++ files. The `TestCase` subclasses are the various testing modules available to the autograde system.

2. The second step is to execute the `TestCompileCPP` object and record test results using one of there following functions like:

        $compiles = $this->run($tc);
        $pts = 5;
        $compiles = $this->pass($tc, $pts, "Compiled $testFile");
        $compiles = $this->fail($tc, -$pts, "Did not compile: $testFile");

    The variable $pts in the above represent the number of points to add. Use a negative value to take off points.

    We may nest test cases in the function calls to both create and execute a test case like:

        $compiles = $this->run(new TestCompileCPP($testFile));

    If we want to remove all compiled files before compiling, we may call the deleteGlobRec() function like the following:

        deleteGlobRec("*.[eE][xX][eE]", $this->dir); // Windows executable
        deleteGlobRec("*.o", $this->dir);   // Object files

    The function `deleteGlobRec()` is documented in the `util.php` file.

## 3. Run compiled program with defined input and save the output.

We now run the compiled file with defined input and save the output. The `Grader` class has a function to run and log commands.

    /**
        Runs $testCmd and logs the output in $outFile.

        @param $testCmd The test command to run.
        @param $outFile The file in which to save the output.
        @param $cond Whether or not to run the $testCmd.
        @param $timeout The max number of seconds to run before terminating.
        @return the output written to the log file
        NTR: does not timeout if held by cin statement.
     */
    function runLogCmd($testCmd, $outFile="out.log", $cond=true, $timeout=5)

The `$testCmd` variable is the command you would use if running at the command line in a terminal window. Like most grading systems, we use input and output redirection at the command line. For example, if we wanted to run the hello executable file with input redirection from an input file, we would type:

    $this->runLogCmd("hello < ../../docs/input1.txt");

Oftentimes, students do not use the correct file name. Also, students may put their work in subfolders. Thus we can capture the correct filename from our `$testFile` variable from step 1 with some PHP commands like:

    // Find executable file
    $path = dirname($testFile);
    if ($path == NULL) $path =".";
    $exe = $path.DIRECTORY_SEPARATOR."$baseName.exe";

Once we know the executable pathname, we construct a more robust output command and call the `runLogCmd()` function like:

    // Execute with predefined input.
    $cmd = "$exe < ../../docs/input1.txt";
    $this->runLogCmd($cmd, "out.log", true, 5);

Usually, we want to try to run the file only if the code compiled. We can start with a simple test of the `compiles` property set by `TestCompileCPP`. Then include the rest of the code for a script with all the options like:

    if ($this->getProperty("compiles")) {
        // Find executable file
        $path = dirname($testFile);
        if ($path == NULL) $path =".";
        $exe = $path.DIRECTORY_SEPARATOR."$baseName.exe";
        // Execute with predefined input.
        $cmd = "$exe < input1.txt";
        $this->runLogCmd($cmd, "out1.log", true, 3);
    //...

The output from running the command is saved in the `out2.log` file, which we can examine for correctness as shown in the next section.

## 4. Check the output and comment on problems.

We use one or more test cases to check the output, assign a score, and comment on problems. The test cases are subclasses of class `TestCase`. We will look at several examples of TestCase subclasses in this section. File `testcase.php` has all the documentation.

Before we apply a test case, we find it convenient to load the output file into a `FileContents` object.

    $fc1 = new FileContents("out1.log");

A `FileContents` object allows us to preprocess the data file (`out1.log`) to prepare it for testing. As an example, when we execute the `runLogCmd()` function, it adds the following identifying information to the start of the file:

    *Command: .\hello.exe < input.txt
    Results: (out1.log)


We do not want these information lines to interfere with our test cases. Thus, we remove the first three lines of the data file with a command:

    $fc1->removeLines(0, 3);

The `FileContents` class has several other methods for manipulating the contents of a file. These methods are documented in the `filecontents.php` file.

We can apply many test cases to the output. A fairly easy test case is to compare the student output against a the output of the instructor's solution using `TestCompareFiles`.

    // Compare student output against instructor's solution output
    $outFC1 = new FileContents("../../docs/output1.txt");
    $tc = new TestCompareFiles($fc1, $outFC1);
    $this->fail($tc, -6, "Wrong output for: $testFile");

If we want to provide feedback with more detail, we use other test cases such as `TestMatch`. A `TestMatch` will search a `FileContent` object for a matching regular expression. We use one of the three functions for executing a `TestCase` to provide commentary and apply points.

    // More detailed test cases
    $tc = new TestMatch("/Hello/", $outFC1);
    $this->fail($tc, -1, "Missing the word \"Hello\"");
    $tc = new TestMatch("/Indigo/", $outFC1);
    $this->fail($tc, -5, "Missing name");

## 5. Check the source code file for any required elements.

As with the program output, we may optionally apply test cases against the source code file. For example, we can load the source code into a `FileContents` object.

    $tfc = new FileContents($testFile);

To make sure we are not confused by comments, we can strip the source code of all comments, like:

    $tfc->stripComments();

After preparing the source code file, we can search for required code elements. For example, the following verifies the use of a cin statement:

    $tc = new TestMatch("/\bcin\b/", $tfc);
    $this->fail($tc, -5, "Missing cin statement", $testFile);

Notice the fourth argument of `$testFile` in the last line above. The method `findClosestFile()` may return an empty string, which PHP will interpret as false in a boolean context. By adding the fourth argument, we are adding a test condition to prevent executing the `fail()` method when there is no source code file and adding a meaningless comment about missing code.

## 6. Evaluate and score the combined test cases.

After applying the test cases, we evaluate the results using an `Evaluator`. An evaluator can sum up the points or look for certain results in a section. For example, the `ValueEvaluator` calculates a score by summing the points assigned to each test and subtracting from an initial score. We then apply the evaluator using the `report()` method of the Grader class.

    $eval = new ValueEvaluator(10, 10, $compiles ? 1 : 0);
    $score = $this->report($eval, "Score for $testFile:");

An evaluator also ends one section of the test and allows you to go on to test other items or files. For example, we could have separated the example tests into compiling, execution and code compliance sections with a different evaluator for each section. This allows us to structure rubrics in a flexible manner.

We may finish a script by calling the `reportOverall()` method of `Grader` to provide a comment based on an overall percentage. This provides an "executive summary" for the student.

See the complete test script in the file: script-hello.php.
